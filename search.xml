<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>导致JavaScript中this指向混乱的原因</title>
    <url>/2023/07/09/%E5%AF%BC%E8%87%B4JavaScript%E4%B8%ADthis%E6%8C%87%E5%90%91%E6%B7%B7%E4%B9%B1%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<h4 id="在-JavaScript-中，this-关键字的指向通常是动态的，而不是静态的。这意味着-this-可以根据上下文环境的变化而发生改变，导致它的指向变得混乱或难以预测。常见的导致-this-指向混乱的原因包括以下几个方面："><a href="#在-JavaScript-中，this-关键字的指向通常是动态的，而不是静态的。这意味着-this-可以根据上下文环境的变化而发生改变，导致它的指向变得混乱或难以预测。常见的导致-this-指向混乱的原因包括以下几个方面：" class="headerlink" title="在 JavaScript 中，this 关键字的指向通常是动态的，而不是静态的。这意味着 this 可以根据上下文环境的变化而发生改变，导致它的指向变得混乱或难以预测。常见的导致 this 指向混乱的原因包括以下几个方面："></a>在 JavaScript 中，this 关键字的指向通常是动态的，而不是静态的。这意味着 this 可以根据上下文环境的变化而发生改变，导致它的指向变得混乱或难以预测。常见的导致 this 指向混乱的原因包括以下几个方面：</h4><ol>
<li><p>函数调用方式不同：当一个函数被调用时，它的 this 值取决于调用方式。如果使用普通函数调用方式（如 func()），则 this 会指向全局对象 window；如果使用方法调用方式（如 obj.func()），则 this 会指向调用该方法的对象。</p>
</li>
<li><p>箭头函数的使用：箭头函数不具有自己的 this 值，它会捕获上下文中的 this 值。因此，如果在箭头函数中访问 this，它将引用外层作用域中的 this 值。</p>
</li>
<li><p>使用 apply、call 和 bind 方法：apply、call 和 bind 方法可以改变函数执行时的 this 值。其中，apply 和 call 方法可以立即执行函数并传入参数，而 bind 方法可以返回一个新函数，该函数的 this 值被绑定到指定的对象上。</p>
</li>
<li><p>DOM 事件处理程序的使用：在处理 DOM 事件时，浏览器会将事件处理程序内部的 this 指向触发事件的元素。但是，在使用 addEventListener 方法绑定事件处理程序时，this 会指向全局对象 window，而不是目标元素。</p>
</li>
<li><p>对象的嵌套和继承：当一个对象被嵌套在另一个对象中或者使用继承时，this 的指向可能会变得混乱。这是因为 this 的指向取决于函数被调用时的上下文环境，而不是对象本身。因此，在嵌套对象或继承类中使用 this 时，需要特别注意它的指向。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化方案 CommonJS、AMD、CMD、ES Module</title>
    <url>/2023/07/11/%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88%20CommonJS%E3%80%81AMD%E3%80%81CMD%E3%80%81ES%20Module/</url>
    <content><![CDATA[<p><strong>时间轴：CommonJS –&gt; AMD –&gt; CMD –&gt; ES Module</strong></p>
<h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><ul>
<li><p>常用于：<code>服务器端</code>，<code>node</code>，<code>webpack</code></p>
</li>
<li><p>特点：<code>同步/运行时加载</code>，<code>磁盘读取速度快</code></p>
</li>
<li><p>语法：</p>
</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导出：通过module.exports或exports来暴露模块  </span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;  </span><br><span class="line">  attr1,  </span><br><span class="line">  attr2  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">exports</span>.<span class="property">attr</span> = xx  </span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong>不可以<code>exports = xxx</code>，这样写会无效，因为更改了exports的地址，而 <code>exports</code> 是 <code>module.exports</code> 的引用指向的是同一个内存，模块最后导出的是 <code>module.exports</code> </p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 引用：require(&#x27;x&#x27;)  </span></span><br><span class="line"><span class="keyword">const</span> xx = <span class="built_in">require</span>(<span class="string">&#x27;xx&#x27;</span>) <span class="comment">// 整体重命名  </span></span><br><span class="line"><span class="keyword">const</span> &#123; attr &#125; = <span class="built_in">require</span>(<span class="string">&#x27;xx&#x27;</span>) <span class="comment">// 解构某一个导出</span></span><br></pre></td></tr></table></figure></div>

<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><ul>
<li><p>常用于：不常用，<code>CommonJs的浏览器端实现</code></p>
</li>
<li><p>特点： </p>
<ul>
<li><code>异步加载</code>：因为面向浏览器端，为了不影响渲染肯定是异步加载</li>
<li><code>依赖前置</code>：所有的依赖必须写在最初的依赖数组中，速度快，但是会浪费资源，预先加载了所有依赖不管你是否用到</li>
</ul>
<p>语法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导出：通过define来定义模块  </span></span><br><span class="line"><span class="comment">// 如果该模块还依赖其他模块，则将模块的路径填入第一个参数的数组中  </span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;x&#x27;</span>], <span class="keyword">function</span>(<span class="params">x</span>)&#123;  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;  </span><br><span class="line">      <span class="keyword">return</span> x.<span class="title function_">fn</span>() + <span class="number">1</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> &#123;  </span><br><span class="line">      <span class="attr">foo</span>: foo  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="comment">// 2. 引用  </span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;a&#x27;</span>], <span class="keyword">function</span> (<span class="params">a</span>)&#123;  </span><br><span class="line">  a.<span class="title function_">foo</span>()  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><ul>
<li><p>常用于：不常用，<code>根据CommonJs和AMD实现，优化了加载方式</code></p>
</li>
<li><p>特点： </p>
<ul>
<li><code>异步加载</code></li>
<li><code>按需加载/依赖就近</code>：用到了再引用依赖，方便了开发，缺点是速度和性能较差</li>
</ul>
<p>语法：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导出：通过define来定义模块  </span></span><br><span class="line"><span class="comment">// 如果该模块还依赖其他模块，在用到的地方引用即可  </span></span><br><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;  </span><br><span class="line">      <span class="keyword">var</span> x = <span class="built_in">require</span>(<span class="string">&#x27;x&#x27;</span>)  </span><br><span class="line">      <span class="keyword">return</span> x.<span class="title function_">fn</span>() + <span class="number">1</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> &#123;  </span><br><span class="line">      <span class="attr">foo</span>: foo  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;);  </span><br><span class="line"><span class="comment">// 2. 引用  </span></span><br><span class="line"><span class="keyword">var</span> x = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);  </span><br><span class="line">a.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="ES-module"><a href="#ES-module" class="headerlink" title="ES module"></a>ES module</h4><ul>
<li>常用于：<code>目前浏览器端的默认标准</code></li>
<li>特点：<code>静态编译：</code> 在编译的时候就能确定依赖关系，以及输入和输出的变量</li>
<li>语法：</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导出：通过export 或 export default 输出模块  </span></span><br><span class="line"><span class="comment">// 写法1: 边声明，边导出  </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">m</span>(<span class="params"></span>) &#123;&#125;;  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">M</span> &#123;&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2：导出一个接口 export &#123;&#125;，形似导出对象但不是, 本质上是引用集合，最常用的导出方法  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;  </span><br><span class="line">  attr1,  </span><br><span class="line">  attr2  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3：默认导出  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fn  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 引用  </span></span><br><span class="line"><span class="keyword">import</span> &#123; x &#125; <span class="keyword">from</span> <span class="string">&#x27;test.js&#x27;</span> <span class="comment">// 导出模块中对应的值，必须知道值在模块中导出时的名字  </span></span><br><span class="line"><span class="keyword">import</span> &#123; x <span class="keyword">as</span> myx &#125; <span class="keyword">from</span> <span class="string">&#x27;test.js&#x27;</span> <span class="comment">// 改名字  </span></span><br><span class="line"><span class="keyword">import</span> x <span class="keyword">from</span> <span class="string">&#x27;test.js&#x27;</span> <span class="comment">// 默认导出的引用方式  </span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong></p>
<ol>
<li><code>export default</code>在同一个文件中只可存在一个（一个模块只能有一个默认输出）</li>
<li>一个模块中可以同时使用export default 和 export</li>
</ol>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块 test.js</span></span><br><span class="line"><span class="keyword">var</span> info = &#123;  </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,  </span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> info  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name= <span class="string">&#x27;海洋饼干&#x27;</span>  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> age = <span class="number">18</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用  </span></span><br><span class="line"><span class="keyword">import</span> person, &#123;name, age <span class="keyword">as</span> myAge&#125; <span class="keyword">from</span> <span class="string">&#x27;test.js&#x27;</span>  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123; name: &#x27;name&#x27;, age: 18 &#125;  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name+ <span class="string">&#x27;=&#x27;</span> + myAge); <span class="comment">// 海洋饼干=18</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>触发BFC的方式以及应用场景</title>
    <url>/2023/07/13/%E8%A7%A6%E5%8F%91BFC%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h4 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h4><p>常说的文档流其实分为<code>定位流</code>、<code>浮动流</code>、<code>普通流</code>三种 </p>
<h4 id="绝对定位（-Absolute-positioning-）"><a href="#绝对定位（-Absolute-positioning-）" class="headerlink" title="绝对定位（ Absolute positioning ）"></a>绝对定位（ Absolute positioning ）</h4><p>如果元素的属性 <code>position</code> 为 <code>absolute</code> 或 <code>fixed</code>，它就是一个绝对定位元素。 </p>
<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 </p>
<p>它的定位相对于它的包含块，相关CSS属性：<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>； </p>
<p>对于 <code>position: absolute</code>，元素定位将相对于上级元素中最近的一个<code>relative、fixed、absolute</code>，如果没有则相对于body； </p>
<p>对于 <code>position:fixed</code>，正常来说是相对于浏览器窗口定位的，但是当<strong>元素祖先的 transform 属性非 none 时，会相对于该祖先进行定位</strong>。 </p>
<h4 id="浮动（-float-）"><a href="#浮动（-float-）" class="headerlink" title="浮动（ float ）"></a>浮动（ float ）</h4><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 </p>
<h4 id="普通流（-normal-flow-）"><a href="#普通流（-normal-flow-）" class="headerlink" title="普通流（ normal flow ）"></a>普通流（ normal flow ）</h4><p>普通流其实就是指BFC中的FC。FC<code>Formatting Context</code>，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。 </p>
<p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行。块级元素则会被渲染为完整的一个新行。 </p>
<p>除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 </p>
<h4 id="BFC-概念"><a href="#BFC-概念" class="headerlink" title="BFC 概念"></a>BFC 概念</h4><p>MDN上关于BFC的定义： </p>
<blockquote>
<p>块格式化上下文（<code>Block Formatting Context</code>，<code>BFC</code>） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 </p>
</blockquote>
<p>具有 <code>BFC</code> 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 <code>BFC</code> 具有普通容器所没有的一些特性。 </p>
<p>通俗一点来讲，可以把 <code>BFC</code> 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 </p>
<p>除了 BFC，还有：</p>
<ul>
<li><code>IFC</code>（行级格式化上下文）- <code>inline</code> 内联</li>
<li><code>GFC</code>（网格布局格式化上下文）- <code>display: grid</code></li>
<li><code>FFC</code>（自适应格式化上下文）- <code>display: flex</code>或<code>display: inline-flex</code></li>
</ul>
<p><strong>注意</strong>：同一个元素不能同时存在于两个 <code>BFC</code> 中。 </p>
<h4 id="BFC的触发方式"><a href="#BFC的触发方式" class="headerlink" title="BFC的触发方式"></a>BFC的触发方式</h4><p>MDN上对于<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" >BFC的触发条件</a>写的很多，总结一下常见的触发方式有（只需要满足一个条件即可触发 BFC 的特性）：</p>
<ul>
<li>根元素，即 <code>&lt;html&gt;</code></li>
<li>浮动元素：<code>float</code> 值为 <code>left</code> 、<code>right</code></li>
<li><code>overflow</code> 值不为 <code>visible</code>，即为 <code>auto</code>、<code>scroll</code>、<code>hidden</code></li>
<li><code>display</code> 值为 <code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>table</code>、<code>inline-table</code>、<code>flex</code>、<code>inline-flex</code>、<code>grid</code>、<code>inline-grid</code></li>
<li>绝对定位元素：<code>position</code> 值为 <code>absolute</code>、<code>fixed</code></li>
</ul>
<h4 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h4><ul>
<li>BFC 是页面上的一个独立容器，容器里面的子元素不会影响外面的元素。</li>
<li>BFC 内部的块级盒会在垂直方向上一个接一个排列</li>
<li>同一 BFC 下的相邻块级元素可能发生外边距折叠，创建新的 BFC 可以避免外边距折叠</li>
<li>每个元素的外边距盒（<code>margin box</code>）的左边与包含块边框盒（<code>border box</code>）的左边相接触（从右向左的格式的话，则相反），即使存在浮动</li>
<li>浮动盒的区域不会和 BFC 重叠</li>
<li>计算 BFC 的高度时，浮动元素也会参与计算</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。我们可以利用BFC的这个特性来做很多事。 </p>
<p><strong>自适应两列布局</strong></p>
<p>左列浮动（ 定宽或不定宽都可以 ），给右列开启 BFC。 </p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>浮动元素，无固定宽度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>效果： </p>
<ul>
<li>将左列设为左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行的位置。</li>
<li>右列为 div 块级元素，利用其自身的流特性占满整行。</li>
<li>右列设置overflow: hidden,触发 BFC 特性，使其自身与左列的浮动元素隔离开，不占满整行。</li>
</ul>
<p><strong>防止外边距（ margin ）重叠</strong></p>
<p>兄弟元素之间的外边距重叠 </p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>效果： </p>
<p>两个块级元素，红色 div 距离底部 10px，绿色 div 距离顶部 20px，按道理应该两个块级元素相距 30px 才对，但实际却是取距离较大的一个，即 20px。 </p>
<blockquote>
<p>块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的较大者，这种行为称为外边距折叠（重叠），注意这个是发生在属于同一 BFC 下的块级元素之间 </p>
</blockquote>
<p>根据 BFC 特性，创建一个新的 BFC 就不会发生 margin 折叠了。比如我们在他们两个 div 外层再包裹一层容器，加属性 <code>overflow: hidden</code>，触发 BFC，那么两个 div 就不属于同个 BFC 了。 </p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>关于兄弟元素外边距叠加的问题，除了触发 BFC 也有其他方案，比如你统一只用上边距或下边距，就不会有上面的问题。 </p>
<h4 id="父子元素的外边距重叠"><a href="#父子元素的外边距重叠" class="headerlink" title="父子元素的外边距重叠"></a>父子元素的外边距重叠</h4><p>这种情况存在父元素与其第一个或最后一个子元素之间（ 嵌套元素 ）。 </p>
<p>如果在父元素与其第一个&#x2F;最后一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的外边距 分开，此时子元素的外边距会“溢出”到父元素的外面。 </p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>红色的 div 在绿色的 div 内部，且设置了 <code>margin-top</code> 为 30px，但我们发现红色 div 的顶部与绿色 div 顶部重合，并没有距离顶部 30px，而是溢出到父元素的外面计算。即本来父元素距离顶部只有 20px，被子元素溢出影响，外边距重叠，取较大的值，则距离顶部 30px。 </p>
<p>解决办法：</p>
<ul>
<li>给父元素触发 BFC（ 如添加overflow: hidden ）</li>
<li>给父元素添加 border</li>
<li>给父元素添加 padding</li>
</ul>
<h4 id="清除浮动解决令父元素高度坍塌的问题"><a href="#清除浮动解决令父元素高度坍塌的问题" class="headerlink" title="清除浮动解决令父元素高度坍塌的问题"></a>清除浮动解决令父元素高度坍塌的问题</h4><p>当容器内子元素设置浮动时，脱离了文档流，容器中总父元素高度只有边框部分高度。 </p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>解决办法：给父元素触发 BFC，使其有 BFC 特性：<strong>计算 BFC 的高度时，浮动元素也会参与计算</strong> </p>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面我们都是用的 <code>overflow: hidden</code> 触发 BFC，因为确实常用，但是触发 BFC 也不止是只有这一种方法。 </p>
<p>如上面写的所示，可以设置<code>float: left;</code>，<code>float: right;</code>，<code>display: inline-block;</code>，<code>overflow: auto;</code>，<code>display: flex;</code>，<code>display: table;</code>，<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code> 等等，这些都可以触发，不过父元素宽度表现不一定相同，但父元素高度都被撑出来了。 </p>
<p>实际运用还是根据场景选择。 </p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>理解回流重绘以及触发场景</title>
    <url>/2023/07/16/%E7%90%86%E8%A7%A3%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%BB%A5%E5%8F%8A%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../media/images/articles/%E7%90%86%E8%A7%A3%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%BB%A5%E5%8F%8A%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF-01.png"
                      alt="理解回流重绘以及触发场景-01"
                ></p>
<h4 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h4><p>在<code>HTML</code>中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：</p>
<ul>
<li>回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置</li>
<li>重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</li>
</ul>
<p>具体的浏览器解析渲染机制如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../media/images/articles/%E7%90%86%E8%A7%A3%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98%E4%BB%A5%E5%8F%8A%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF-02.png"
                      alt="理解回流重绘以及触发场景-02"
                ></p>
<ul>
<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>
<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>
<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>
<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>
<li>Display:将像素发送给GPU，展示在页面上</li>
</ul>
<p>在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变</p>
<p>当我们对 <code>DOM</code> 的修改引发了 <code>DOM </code>几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来</p>
<p>当我们对 <code>DOM </code>的修改导致了样式的变化（<code>color</code>或<code>background-color</code>），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里就仅仅触发了重绘</p>
<h4 id="二、如何触发"><a href="#二、如何触发" class="headerlink" title="二、如何触发"></a>二、如何触发</h4><p>要想减少回流和重绘的次数，首先要了解回流和重绘是如何触发的 </p>
<p><strong>回流触发时机</strong></p>
<p>回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流，如下面情况：</p>
<ul>
<li>添加或删除可见的DOM元素</li>
<li>元素的位置发生变化</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</li>
<li>页面一开始渲染的时候（这避免不了）</li>
<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
</ul>
<p>还有一些容易被忽略的操作：获取一些特定属性的值</p>
<blockquote>
<p>offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</p>
</blockquote>
<p>这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流</p>
<p>除此还包括<code>getComputedStyle </code>方法，原理是一样的</p>
<p><strong>重绘触发时机</strong></p>
<p>触发回流一定会触发重绘</p>
<p>可以把页面理解为一个黑板，黑板上有一朵画好的小花。现在我们要把这朵从左边移到了右边，那我们要先确定好右边的具体位置，画好形状（回流），再画上它原有的颜色（重绘）</p>
<p>除此之外还有一些其他引起重绘行为：</p>
<ul>
<li>颜色的修改</li>
<li>文本方向的修改</li>
<li>阴影的修改</li>
</ul>
<p><strong>浏览器优化机制</strong></p>
<p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p>
<p>当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的<code>offsetTop</code>等方法都会返回最新的数据</p>
<p>因此浏览器不得不清空队列，触发回流重绘来返回正确的值</p>
<h4 id="三、如何减少"><a href="#三、如何减少" class="headerlink" title="三、如何减少"></a>三、如何减少</h4><p>我们了解了如何触发回流和重绘的场景，下面给出避免回流的经验：</p>
<ul>
<li>如果想设定元素的样式，通过改变元素的 <code>class</code> 类名 (尽可能在 DOM 树的最里层)</li>
<li>避免设置多项内联样式</li>
<li>应用元素的动画，使用 <code>position</code> 属性的 <code>fixed</code> 值或 <code>absolute</code> 值(如前文示例所提)</li>
<li>避免使用 <code>table</code> 布局，<code>table</code> 中每个元素的大小以及内容的改动，都会导致整个 <code>table</code> 的重新计算</li>
<li>对于那些复杂的动画，对其设置 <code>position: fixed/absolute</code>，尽可能地使元素脱离文档流，从而减少对其他元素的影响</li>
<li>使用css3硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘</li>
<li>避免使用 CSS 的 <code>JavaScript</code> 表达式</li>
</ul>
<p>在使用 <code>JavaScript</code> 动态插入多个节点时, 可以使用<code>DocumentFragment</code>. 创建后一次插入. 就能避免多次的渲染性能</p>
<p>但有时候，我们会无可避免地进行回流或者重绘，我们可以更好使用它们</p>
<p>例如，多次修改一个把元素布局的时候，我们很可能会如下操作</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;el&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">top</span>  = el.<span class="property">offsetTop</span>  + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    el.<span class="property">style</span>.<span class="property">left</span> = el.<span class="property">offsetLeft</span> + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>每次循环都需要获取多次<code>offset</code>属性，比较糟糕，可以使用变量的形式缓存起来，待计算完毕再提交给浏览器发出重计算请求</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存offsetLeft与offsetTop的值</span></span><br><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;el&#x27;</span>) </span><br><span class="line"><span class="keyword">let</span> offLeft = el.<span class="property">offsetLeft</span>, offTop = el.<span class="property">offsetTop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JS层面进行计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">  offLeft += <span class="number">10</span></span><br><span class="line">  offTop  += <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次性将计算结果应用到DOM上</span></span><br><span class="line">el.<span class="property">style</span>.<span class="property">left</span> = offLeft + <span class="string">&quot;px&quot;</span></span><br><span class="line">el.<span class="property">style</span>.<span class="property">top</span> = offTop  + <span class="string">&quot;px&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>我们还可避免改变样式，使用类名去合并样式 </p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>使用类名去合并样式 </p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.basic_style</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">10px</span> solid red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    container.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;basic_style&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>前者每次单独操作，都去触发一次渲染树更改（新浏览器不会），</p>
<p>都去触发一次渲染树更改，从而导致相应的回流与重绘过程</p>
<p>合并之后，等于我们将所有的更改一次性发出</p>
<p>我们还可以通过通过设置元素属性<code>display: none</code>，将其从页面上去掉，然后再进行后续操作，这些后续操作也不会触发回流与重绘，这个过程称为离线操作</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>离线操作后 </p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line">container.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;100px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">border</span> = <span class="string">&#x27;10px solid red&#x27;</span></span><br><span class="line">container.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">...（省略了许多类似的后续操作）</span><br><span class="line">container.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span></span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>优化页面加载白屏时间</title>
    <url>/2023/07/18/%E4%BC%98%E5%8C%96%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h4 id="一、白屏时间"><a href="#一、白屏时间" class="headerlink" title="一、白屏时间"></a>一、白屏时间</h4><p>白屏时间：即用户点击一个链接或打开浏览器输入URL地址后，从屏幕空白到显示第一个画面的时间。 </p>
<h4 id="二、白屏时间的重要性"><a href="#二、白屏时间的重要性" class="headerlink" title="二、白屏时间的重要性"></a>二、白屏时间的重要性</h4><p>当用户点开一个链接或者是直接在浏览器中输入URL开始进行访问时，就开始等待页面的展示。页面渲染的时间越短，用户等待的时间就越短，用户感知到页面的速度就越快。这样可以极大地<strong>提升用户的体验，减少用户的跳出，提升页面的留存率。</strong> </p>
<h4 id="三、白屏的过程"><a href="#三、白屏的过程" class="headerlink" title="三、白屏的过程"></a>三、白屏的过程</h4><p>从输入url，到页面的画面展示的过程</p>
<p>1、首先，在浏览器地址栏中输入url</p>
<p>2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。</p>
<p>3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。</p>
<p>4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。</p>
<p>5、握手成功后，浏览器向服务器发送http请求，请求数据包。</p>
<p>6、服务器处理收到的请求，将数据返回至浏览器</p>
<p>7、浏览器收到HTTP响应</p>
<p>8、读取页面内容，浏览器渲染，解析html源码</p>
<p>9、生成Dom树、解析css样式、js交互,渲染显示页面</p>
<p>浏览器下载HTML后，首先解析头部代码，进行样式表下载，然后继续向下解析HTML代码，构建DOM树，同时进行样式下载。当DOM树构建完成后，立即开始构造CSSOM树。理想情况下，样式表下载速度够快，DOM树和CSSOM树进入一个并行的过程，当两棵树构建完毕，构建渲染树，然后进行绘制。</p>
<p>Tips:浏览器安全解析策略对解析HTML造成的影响：</p>
<p>当解析HTML时遇到内联JS代码，会阻塞DOM树的构建，会先执行完JS代码;当CSS样式文件没有下载完成时，浏览器解析HTML遇到了内联JS代码，此时，浏览器暂停JS脚本执行，暂停HTML解析。直到CSS文件下载完成，完成CSSOM树构建，重新恢复原来的解析。</p>
<h4 id="四、白屏-性能优化"><a href="#四、白屏-性能优化" class="headerlink" title="四、白屏-性能优化"></a>四、白屏-性能优化</h4><p><strong>1. DNS解析优化</strong></p>
<p>针对DNS Lookup环节，我们可以针对性的进行DNS解析优化。</p>
<ul>
<li>DNS缓存优化</li>
<li>DNS预加载策略</li>
<li>稳定可靠的DNS服务器</li>
</ul>
<p><strong>2. TCP网络链路优化</strong></p>
<p>多花点钱吧</p>
<p><strong>3. 服务端处理优化</strong></p>
<p>服务端的处理优化，是一个非常庞大的话题，会涉及到如Redis缓存、数据库存储优化或是系统内的各种中间件以及Gzip压缩等… </p>
<p><strong>4. 浏览器下载、解析、渲染页面优化</strong></p>
<p>根据浏览器对页面的下载、解析、渲染过程，可以考虑一下的优化处理：</p>
<ul>
<li>尽可能的精简HTML的代码和结构</li>
<li>尽可能的优化CSS文件和结构</li>
<li>一定要合理的放置JS代码，尽量不要使用内联的JS代码</li>
<li>将渲染首屏内容所需的关键CSS内联到HTML中，能使CSS更快速地下载。在HTML下载完成之后就能渲染了，页面渲染的时间提前，从而缩短首屏渲染时间；</li>
<li>延迟首屏不需要的图片加载，而优先加载首屏所需图片（offsetTop&lt;clientHeight）</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span><span class="comment">//获取屏幕可视区域的高度</span></span><br><span class="line">element.<span class="property">offsetTop</span><span class="comment">//获取元素相对于文档顶部的高度</span></span><br></pre></td></tr></table></figure></div>

<p>因为JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。 </p>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>前端如何选择图片的格式</title>
    <url>/2023/07/16/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87%E7%9A%84%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>图片的类型目前就分为两种：</p>
<ul>
<li>位图</li>
<li>矢量图</li>
</ul>
<p><strong>位图</strong></p>
<p>所谓位图就是用像素点拼起来的图也叫点阵图，平时我们用到的png、jpg等图片就是位图。</p>
<p><strong>矢量图</strong></p>
<p>矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一幅矢量图的时候，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看。 </p>
<p>无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，它也不会像位图那样会失真。</p>
<p>常见的就是svg格式的。</p>
<h4 id="图片的压缩类型"><a href="#图片的压缩类型" class="headerlink" title="图片的压缩类型"></a>图片的压缩类型</h4><ul>
<li>无压缩</li>
<li>有损压缩</li>
<li>无损压缩</li>
</ul>
<p><strong>无压缩</strong></p>
<p>无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。例如BMP格式的图片。 </p>
<p><strong>有损压缩</strong></p>
<p>指在压缩文件大小的过程中，损失了一部分图片的信息，即降低了图片的质量（图片被压糊了），并且这种损失是不可逆的。 </p>
<p>常见的有损压缩手段是按照一定的算法将临近的像素点进行合并。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的体积。例如jpg格式的图片使用的就是有损压缩。 </p>
<p><strong>无损压缩</strong></p>
<p>在压缩图片的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。 </p>
<p>压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的体积。例如png、gif使用的就是无损压缩。 </p>
<h4 id="图片位数"><a href="#图片位数" class="headerlink" title="图片位数"></a>图片位数</h4><p>图片位数通常分为8、16、24、32</p>
<ul>
<li>图片位数越大，能表示的颜色越多，同时占用的体积也约大。例如8位图片支持256种颜色，即2的8次方。</li>
<li>图片位数越大，颜色过渡也就越细腻，携带的色彩信息可以更加丰富。</li>
<li>32位跟24位的区别就是多了一个Alpha通道，用来支持半透明，其他的跟24位基本一样。</li>
</ul>
<h4 id="常见的图片的格式"><a href="#常见的图片的格式" class="headerlink" title="常见的图片的格式"></a>常见的图片的格式</h4><p><strong>GIF</strong></p>
<p>GIF的全称是<code>Graphics Interchange Format</code>，可译为图形交换格式，是在1987年由Compu Serve公司为了填补跨平台图像格式的空白而发展起来的。</p>
<p>GIF采用的是Lempel-Zev-Welch（LZW）压缩算法，最高支持256种颜色。由于这种特性，GIF比较适用于色彩较少的图片，比如卡通造型、公司标志等等。如果碰到需要用24位真彩色的场合，那么GIF的表现力就有限了。</p>
<p>GIF格式图片最大的特性是帧动画，相比古老的bmp格式，尺寸较小，而且支持透明( 不支持半透明，因为不支持 Alpha 透明通道 )和动画。</p>
<p>优点：</p>
<ul>
<li>体积小</li>
<li>支持动画</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于采用了8位压缩，最多只能处理256种颜色</li>
</ul>
<p><strong>JPEG&#x2F;JPG</strong></p>
<p>JPEG是<code>Joint Photographic Experts Group</code>(联合图像专家组)的缩写，文件后辍名为”．jpg”或”．jpeg”，是常用的图像文件格式，由一个软件开发联合会组织制定，是一种有损压缩格式，能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。 </p>
<p>优点：</p>
<ul>
<li>采用有损压缩，压缩后体积更小</li>
<li>支持24位真彩色</li>
<li>支持渐进式加载</li>
</ul>
<p>缺点：</p>
<ul>
<li>有损压缩会损坏图片的质量</li>
<li>不支持透明&#x2F;半透明</li>
</ul>
<p><strong>渐进式jpeg(progressive jpeg)</strong></p>
<p>渐进式jpg文件包含多次扫描，这些扫描顺寻的存储在jpg文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。 </p>
<p>PNG</p>
<p>png，即便携式网络图形是一种无损压缩的位图片形格式，其设计目的是试图替代GIF和TIFF文件格式，同时增加一些GIF文件格式所不具备的特性。PNG使用从LZ77派生的无损数据压缩算法，一般应用于JAVA程序、网页或S60程序中，原因是它压缩比高，生成文件体积小。</p>
<p>png支持8位、24位、32位3种，我们通常叫它们png8、png24、png32。</p>
<p>优点：</p>
<ul>
<li>无损压缩</li>
<li>支持透明、半透明</li>
<li>最高支持24位真彩色图像以及8位灰度图像，从而彻底地消除锯齿边缘。</li>
</ul>
<p>缺点：</p>
<ul>
<li>与jpg的有损耗压缩相比，png提供的压缩量较少</li>
<li>不支持动画，如需支持动画还得使用apng</li>
</ul>
<p><strong>APNG</strong></p>
<p>APNG（Animated Portable Network Graphics）是一个基于PNG（Portable Network Graphics）的位图动画格式。实际上就是多张png组成的动图。MAC电脑打开可以看到组成apng的每一张图。</p>
<p>优点：</p>
<ul>
<li>支持png的所有优点</li>
<li>支持动画</li>
</ul>
<p>缺点：</p>
<ul>
<li>浏览器支持情况较差</li>
</ul>
<p><strong>WEBP</strong></p>
<p>WebP是由Google最初在2010年发布，目标是减少文件大小。它能同时支持无损压缩和有损压缩。</p>
<p>它几乎集成了以上所有图片的优点，并且能够拥有更高的压缩率，但是浏览器支持率还不够理想。</p>
<p><strong>SVG</strong></p>
<p>SVG是一种用XML定义的语言，用来描述二维矢量及矢量&#x2F;栅格图形。SVG提供了3种类型的图形对象：矢量图形（例如：由直线和曲线组成的路径）、图象、文本。图形对象还可进行分组、添加样式、变换、组合等操作，特征集包括嵌套变换、剪切路径、alpha蒙板、滤镜效果、模板对象和其它扩展。</p>
<p>SVG图形是可交互的和动态的，可以在SVG文件中嵌入动画元素或通过脚本来定义动画。</p>
<p>SVG与上面图片不同的是它是矢量图，无论你怎么放大，它都不会失真；同时，SVG文件通常要比JPEG和PNG格式的文件要小很多。</p>
<p>优点：</p>
<ul>
<li>SVG 可被非常多的工具读取和修改（比如记事本）</li>
<li>SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。</li>
<li>SVG 是可伸缩</li>
<li>SVG 图像可在任何的分辨率下被高质量地打印</li>
<li>SVG 可在图像质量不下降的情况下被放大</li>
<li>SVG 可以与 JavaScript 技术一起运行</li>
<li>SVG 文件是纯粹的 XML</li>
</ul>
<p>缺点：</p>
<ul>
<li>渲染成本相对于其他格式图片比较高，对于性能有影响。</li>
<li>需要学习成本，因为SVG是一种用XML定义的语言。</li>
</ul>
<h4 id="如何选择图片的格式"><a href="#如何选择图片的格式" class="headerlink" title="如何选择图片的格式"></a>如何选择图片的格式</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../media/images/articles/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87%E7%9A%84%E6%A0%BC%E5%BC%8F-01.png"
                      alt="前端如何选择图片的格式-01"
                ></p>
]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件间通信方式</title>
    <url>/2023/07/07/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="一、组件间通信的分类"><a href="#一、组件间通信的分类" class="headerlink" title="一、组件间通信的分类"></a>一、组件间通信的分类</h4><p>组件间通信的分类可以分成以下</p>
<ul>
<li>父子组件之间的通信</li>
<li>兄弟组件之间的通信</li>
<li>祖孙与后代组件之间的通信</li>
<li>非关系组件间之间的通信</li>
</ul>
<p>关系图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../media/images/articles/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-01.png"
                      alt="Vue组件间通信方式-01"
                ></p>
<h4 id="二、组件间通信的方案"><a href="#二、组件间通信的方案" class="headerlink" title="二、组件间通信的方案"></a>二、组件间通信的方案</h4><p>整理<code>vue</code>中8种常规的通信方案</p>
<ol>
<li>通过 props 传递</li>
<li>通过 $emit 触发自定义事件</li>
<li>使用 ref</li>
<li>EventBus</li>
<li>$parent 或$root</li>
<li>attrs 与 listeners</li>
<li>Provide 与 Inject</li>
<li>Vuex</li>
</ol>
<p><strong>props传递数据</strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../media/images/articles/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-02.png"
                      alt="Vue组件间通信方式-02"
                ></p>
<ul>
<li>适用场景：父组件传递数据给子组件</li>
<li>子组件设置<code>props</code>属性，定义接收父组件传递过来的参数</li>
<li>父组件在使用子组件标签中通过字面量来传递值</li>
</ul>
<p><code>Children.vue </code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;  </span><br><span class="line"> <span class="comment">// 字符串形式  </span></span><br><span class="line"> <span class="attr">name</span>:<span class="title class_">String</span>, <span class="comment">// 接收的类型参数  </span></span><br><span class="line"> <span class="comment">// 对象形式  </span></span><br><span class="line"> <span class="attr">age</span>:&#123;    </span><br><span class="line">     <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">     <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">     <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<p><code>Father.vue</code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> name=<span class="string">&quot;jack&quot;</span> age=<span class="number">18</span> /&gt;  </span><br></pre></td></tr></table></figure></div>

<p><strong>$emit 触发自定义事件</strong></p>
<ul>
<li>适用场景：子组件传递数据给父组件</li>
<li>子组件通过<code>$emit触发</code>自定义事件，<code>$emit</code>第二个参数为传递的数值</li>
<li>父组件绑定监听器获取到子组件传递过来的参数</li>
</ul>
<p><code>Children.vue </code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$emit(<span class="string">&#x27;add&#x27;</span>, good)</span><br></pre></td></tr></table></figure></div>

<p><code>Father.vue </code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> @add=<span class="string">&quot;cartAdd($event)&quot;</span> /&gt;  </span><br></pre></td></tr></table></figure></div>

<p><strong>ref</strong></p>
<ul>
<li>父组件在使用子组件的时候设置<code>ref</code></li>
<li>父组件通过设置子组件<code>ref</code>来获取数据</li>
</ul>
<p>父组件</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Children</span> ref=<span class="string">&quot;foo&quot;</span> /&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">foo</span>  <span class="comment">// 获取子组件实例，通过子组件实例就能拿到对应的数据  </span></span><br></pre></td></tr></table></figure></div>

<p><strong>EventBus</strong></p>
<ul>
<li>使用场景：兄弟组件传值</li>
<li>创建一个中央事件总线<code>EventBus</code></li>
<li>兄弟组件通过<code>$emit</code>触发自定义事件，<code>$emit</code>第二个参数为传递的数值</li>
<li>另一个兄弟组件通过<code>$on</code>监听自定义事件</li>
</ul>
<p><code>Bus.js </code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个中央时间总线类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> &#123;  </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span> = &#123;&#125;;   <span class="comment">// 存放事件的名字  </span></span><br><span class="line">  &#125;  </span><br><span class="line">  $on(name, fn) &#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>[name] = <span class="variable language_">this</span>.<span class="property">callbacks</span>[name] || [];  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callbacks</span>[name].<span class="title function_">push</span>(fn);  </span><br><span class="line">  &#125;  </span><br><span class="line">  $emit(name, args) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">callbacks</span>[name]) &#123;  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">callbacks</span>[name].<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> <span class="title function_">cb</span>(args));  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// main.js  </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="keyword">new</span> <span class="title class_">Bus</span>() <span class="comment">// 将$bus挂载到vue实例的原型上  </span></span><br><span class="line"><span class="comment">// 另一种方式  </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="keyword">new</span> <span class="title class_">Vue</span>() <span class="comment">// Vue已经实现了Bus的功能  </span></span><br></pre></td></tr></table></figure></div>

<p><code>Children1.vue </code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$emit(<span class="string">&#x27;foo&#x27;</span>)  </span><br></pre></td></tr></table></figure></div>

<p><code>Children2.vue </code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;foo&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handle</span>)  </span><br></pre></td></tr></table></figure></div>

<p><strong>$parent 或 $root</strong></p>
<ul>
<li>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信侨联</li>
</ul>
<p>兄弟组件</p>
<p><code>this.$parent.$on(&#39;add&#39;,this.add)</code></p>
<p>另一个兄弟组件</p>
<p><code>this.$parent.$emit(&#39;add&#39;)</code></p>
<p><strong>$attrs 与 $listeners</strong></p>
<ul>
<li>适用场景：祖先传递数据给子孙</li>
<li>设置批量向下传属性<code>$attrs</code>和 <code>$listeners</code></li>
<li>包含了父级作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。</li>
<li>可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传⼊内部组件</li>
</ul>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// child：并未在props中声明foo  </span></span><br><span class="line">&lt;p&gt;&#123;&#123;$attrs.<span class="property">foo</span>&#125;&#125;&lt;/p&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// parent  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">HelloWorld</span> <span class="attr">foo</span>=<span class="string">&quot;foo&quot;</span>/&gt;</span></span>  </span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给Grandson隔代传值，communication/index.vue  </span></span><br><span class="line">&lt;<span class="title class_">Child2</span> msg=<span class="string">&quot;lalala&quot;</span> @some-event=<span class="string">&quot;onSomeEvent&quot;</span>&gt;&lt;/<span class="title class_">Child2</span>&gt;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Child2做展开  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Grandson</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span> <span class="attr">v-on</span>=<span class="string">&quot;$listeners&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Grandson</span>&gt;</span></span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Grandson使⽤  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">&#123;&#123;msg&#125;&#125;  </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> </span><br></pre></td></tr></table></figure></div>

<h4 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h4><ul>
<li>在祖先组件定义<code>provide</code>属性，返回传递的值</li>
<li>在后代组件通过<code>inject</code>接收组件传递过来的值</li>
</ul>
<p>祖先组件</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="params"></span>)&#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">        <span class="attr">foo</span>:<span class="string">&#x27;foo&#x27;</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></div>

<p>后代组件 </p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject</span>:[<span class="string">&#x27;foo&#x27;</span>] <span class="comment">// 获取到祖先组件传递过来的值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><ul>
<li>适用场景: 复杂关系的组件数据传递</li>
<li><code>Vuex</code>作用相当于一个用来存储共享变量的容器</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../media/images/articles/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-03.png"
                      alt="Vue组件间通信方式-03"
                ></p>
<ul>
<li><code>state</code>用来存放共享变量的地方</li>
<li><code>getter</code>，可以增加一个<code>getter</code>派生状态，(相当于<code>store</code>中的计算属性），用来获得共享变量的值</li>
<li><code>mutations</code>用来存放修改<code>state</code>的方法。</li>
<li><code>actions</code>也是用来存放修改state的方法，不过<code>action</code>是在<code>mutations</code>的基础上进行。常用来做一些异步操作</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>父子关系的组件数据传递选择 <code>props</code>  与 <code>$emit</code>进行传递，也可选择<code>ref</code></li>
<li>兄弟关系的组件数据传递可选择<code>$bus</code>，其次可以选择<code>$parent</code>进行传递</li>
<li>祖先与后代组件数据传递可选择<code>attrs</code>与<code>listeners</code>或者 <code>Provide</code>与 <code>Inject</code></li>
<li>复杂关系的组件数据传递可以通过<code>vuex</code>存放共享的变量</li>
</ul>
]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
